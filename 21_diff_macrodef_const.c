/*
1.编译阶段：
宏定义是预处理指令，在预处理阶段进行文本替换，不占用内存空间。
const常量在编译阶段处理，是具有类型的变量，占用内存空间。

2.类型检查：
宏定义没有类型，它只是简单的文本替换，因此不会进行类型检查。
const常量有明确的类型，编译器会进行类型检查。

3.内存分配：
宏定义不分配内存，因为它只是替换代码中的文本。
const常量会分配内存（通常存储在只读数据段或栈上，取决于其作用域和存储类型）。

4.调试：
宏定义在预处理阶段就被替换，因此在调试时无法看到宏名，只能看到替换后的值。
const常量在调试时可以看到变量名和值，便于调试。

5.作用域：
宏定义从定义点开始到文件末尾，除非被#undef取消，它没有作用域的概念（但可以通过#undef来结束其作用域）。
const常量遵循变量的作用域规则（如块作用域、文件作用域等）。

6.安全性：
宏定义由于是文本替换，可能会因为参数没有适当的括号而导致运算符优先级问题，也可能在多次求值时产生副作用（例如，宏参数被求值多次）。
const常量则没有这些问题，因为它是一个变量，求值一次。

7.使用场景：
宏定义可以定义常量、带参数的宏（类似函数）、条件编译等。
const常量只能定义常量，不能带参数。

8.数组大小：
在C语言中，const常量并不总是被视为常量表达式（在C99之前，数组大小必须用常量表达式指定，
而const变量不能用于数组大小，但在C99中可以使用变长数组）。而宏定义可以用于定义数组大小，因为它在预处理时被替换为字面值。

9指针和复合类型：
const可以用于修饰指针，形成指向常量的指针或常量指针，而宏定义不能直接定义指针常量（但可以通过替换文本实现类似效果，但类型安全无法保证）。
*/